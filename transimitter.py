# AUTOGENERATED! DO NOT EDIT! File to edit: transimitter.ipynb (unless otherwise specified).

__all__ = ['QamModulator', 'PulseShaping', 'Laser', 'DAC', 'IQ', 'SignalParam']

# Cell
import numpy as np
from core import QamSignal, Signals
from dataclasses import dataclass

from core import SignalParam


class IQ:
    def __init__(self):
        pass

    def __call__(self, signal, laser):
        return signal


class Laser:

    def __init__(self, center_frequency, power_dbm, is_phase_noise=False, df=None):
        self.center_frequency = center_frequency
        self.power_dbm = power_dbm
        self.is_phase_noise = is_phase_noise
        self.df = df
        self.device = 'cpu'
        self.phase_noise_ = None
        self.phase_noise_ = np.atleast_2d(self.phase_noise_)

    def phase_noise(self, signal):
        from numpy import random, cumsum
        var = 2 * np.pi * self.df / signal.sps_in_fiber / signal.baudrate
        f = random.normal(scale=np.sqrt(var), size=(signal.pol_number, signal.sps_in_fiber * signal.symbol_length))

        self.phase_noise_ = cumsum(f, axis=1)

    def __call__(self, signal: Signals, device: str):

        if self.is_phase_noise:
            self.phase_noise(signal)
            self.to(device)
            signal.to(device)
            signal.samples_in_fiber = signal.samples_in_fiber * np.exp(1j * self.phase_noise_)

    def to(self, device):
        if device.lower() == self.device:
            return

        if device == 'cpu':
            from cupy import asnumpy
            self.phase_noise_ = asnumpy(self.phase_noise_)
            self.device = device

        if device == 'cuda':
            try:
                from cupy import array
            except ImportError:
                raise Exception("CUDA not Supported, please install cupy first")
            self.phase_noise_ = array(self.phase_noise_)
            self.device = device


from typing import Union


class DAC:

    def __init__(self,
                 old: Union[int, float] = None,
                 new: Union[int, float] = None,
                 is_quantize: bool = False,
                 resoultion_bits: int = None,
                 clipping_ratio: float = None):

        self.old = old
        self.new = new
        self.device = 'cpu'
        self.is_quantize = is_quantize
        self.resoultion_bits = resoultion_bits
        self.clipping_ratio = clipping_ratio

    def __call__(self, signal: Signals, device):
        signal.to(device)

        if self.old is None:
            self.old = signal.sps

        if self.new is None:
            self.new = signal.sps_in_fiber

        if device == 'cuda':
            from cusignal import resample_poly as resample
            signal.samples_in_fiber = resample(signal.samples, int(self.new / self.old), 1, axis=1)
        else:
            from resampy import resample
            signal.samples_in_fiber = resample(signal.samples, self.old, self.new)

        if self.is_quantize:
            assert self.clipping_ratio is not None and self.resoultion_bits is not None
            self.quantize(signal, device)
        return signal

    def quantize(self, signal, device):
        signal.to('cpu')

        sig = np.atleast_2d(signal[:])
        npols = sig.shape[0]

        sig_out = np.zeros(sig.shape, dtype="complex")
        for pol in range(npols):
            power = np.mean(np.abs(sig[pol]) ** 2)
            A = 10 ** (self.clipping_ratio / 20) * np.sqrt(power)

            delta = 2 * (1 - A)
            levels_out = np.linspace(-1 + delta / 2, 1 - delta / 2, 2 ** self.resoultion_bits)
            levels_dec = levels_out - (levels_out[1] - levels_out[0]) / 2

            sig_quant_re = levels_out[np.digitize(sig[pol].real, levels_dec[1:], right=False)]
            sig_quant_im = levels_out[np.digitize(sig[pol].imag, levels_dec[1:], right=False)]
            sig_out[pol] = sig_quant_re + 1j * sig_quant_im

        signal.samples_in_fiber = sig_out
        signal.to(device)


class PulseShaping:

    def __init__(self, alpha, span, sps=None):
        '''
        param:
            alpha:roll off factor
            span: FIR filter, the truncated symbol length
            sps: samples per symbol

        Notice:
            if sps is None, it will be set to the signal's sps

        Function:
            design the sqrt root-raised-cosine filter

        '''
        if divmod(span, 2)[1]:
            raise Exception("Span must be even")
        self.alpha = alpha
        self.span = span
        self.sps = sps
        self.delay = None
        self.device = 'cpu'
        self.h = None

    def rcosdesign(self):
        '''
        Function:
            calculate the impulse response of the RRC
        Return:
            b,normalize the max value to 1
        '''
        M = self.span / 2
        n = np.arange(-M * self.sps, M * self.sps + 1)
        b = np.zeros(len(n))
        self.sps *= 1
        a = self.alpha
        Ns = self.sps
        for i in range(len(n)):
            if abs(1 - 16 * a ** 2 * (n[i] / Ns) ** 2) <= np.finfo(np.float).eps / 2:
                b[i] = 1 / 2. * ((1 + a) * np.sin((1 + a) * np.pi / (4. * a)) - (1 - a) * np.cos(
                    (1 - a) * np.pi / (4. * a)) + (4 * a) / np.pi * np.sin((1 - a) * np.pi / (4. * a)))
            else:
                b[i] = 4 * a / (np.pi * (1 - 16 * a ** 2 * (n[i] / Ns) ** 2))
                b[i] = b[i] * (np.cos((1 + a) * np.pi * n[i] / Ns) + np.sinc((1 - a) * n[i] / Ns) * (1 - a) * np.pi / (
                        4. * a))
        return b / np.max(b)

    def to(self, device):

        if device.lower() == self.device:
            return

        if device.lower() == 'cuda':
            from cupy import array
            self.h = array(self.h)
            self.device = 'cuda'
        if device.lower() == 'cpu':
            from cupy import asnumpy
            self.h = asnumpy(self.h)
            self.device = 'cpu'

    def __str__(self):
        return f"PulseShaping(alpha = {self.alpha},span = {self.span}, sps = {self.sps}, device = f{self.device})"

    def __repr__(self):
        return self.__str__()

    def __call__(self, signal: Signals, device):
        if self.sps is None:
            self.sps = signal.sps
            self.delay = int(self.span / 2 * self.sps)

        self.h = self.rcosdesign()
        self.h = np.atleast_2d(self.h)
        self.to(device)
        signal.samples = np.zeros((signal.pol_number, signal.symbol_length * signal.sps), dtype=np.complex)
        signal.samples[:, ::self.sps] = signal.symbol
        signal.to(device)
        from sigdsp import conv
        signal.samples = conv(self.h, signal.samples, self.device)

        # compensate the delay and cut off the sample

        if device == 'cuda':
            from cupy import roll
        else:
            from numpy import roll

        signal.samples = roll(signal.samples, -self.delay, axis=-1)[:, :signal.symbol_length * signal.sps]
        return signal


class QamModulator:

    def __init__(self
                 , laser: Laser
                 , iq_modulator: IQ
                 , pulse_shaping: PulseShaping
                 , dac, signal_param=SignalParam()):
        '''

        :param laser: Laser obj
        :param iq_modulator: IQ obj
        :param pulse_shaping: PulseShaping obj
        :param dac: DAC obj
        :param signal_param: SignalParam obj

        -----------------------------------
        return None
        '''

        self.signal = QamSignal(need_init=True, signal_param=signal_param)
        self.laser = laser
        self.iq_modulator = iq_modulator
        self.pulse_shaping = pulse_shaping
        self.dac = dac
        self.is_modulated = False

    def modulate(self, device):
        '''
        Function:
            Modulate the signal into the optical domain

            RRC pulse shaping--------> DAC-------> IQ modulator
        :return:
            None
        '''
        # pulse shaping
        self.signal = self.pulse_shaping(self.signal, device=device)
        # quantize
        self.signal = self.dac(self.signal, device)
        # iq
        self.signal = self.iq_modulator(self.signal, self.laser)
        self.is_modulated = True

    def __getitem__(self, item):
        return self.signal[item]

    def __getattr__(self, attr):
        if hasattr(self.signal, attr):
            return getattr(self.signal, attr)


def signal_ceshi():
    signal = QamSignal(need_init=True)
    print(signal.sps)
    pulse = PulseShaping(0.02, 1024, 2)
    pulse(signal, 'cuda')
    signal.to('cpu')
    signal.samples_in_fiber = signal.samples
    signal.scatterplot(2)


def laser_ceshi():
    import matplotlib.pyplot as plt
    signal = QamSignal()
    laser = Laser(193.1e12, 0, True, 100 * 1e3)
    laser.phase_noise(signal)
    plt.plot(np.atleast_2d(laser.phase_noise_)[0])
    print(laser.phase_noise_.shape)
    plt.show()


def dac_test():
    signal = QamSignal()
    pulse_shapeing = PulseShaping(0.2, 1024, signal.sps)
    pulse_shapeing(signal, 'cpu')
    dac = DAC(signal.sps, signal.sps_in_fiber, True, 6, 7)
    dac(signal, 'cpu')
    print(signal[:].shape)
    print(signal)
    signal.scatterplot(4)


def transimitter_test():
    laser = Laser(center_frequency=193.1e12, is_phase_noise=False, power_dbm=0)
    dac = DAC()
    train = QamModulator(
                         laser=laser,
                         iq_modulator=IQ(),
                         pulse_shaping=PulseShaping(0.2, 1024),
                         dac=DAC(),
                         signal_param=SignalParam()
                        )

    train.modulate('cpu')
    baudrate = train.baudrate


if __name__ == '__main__':
    transimitter_test()
